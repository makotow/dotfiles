## for performance
# zmodload zsh/zprof


if [[ "$OSTYPE" == darwin* ]]; then
  export BROWSER='open'
fi

# Ensure path arrays do not contain duplicates.
typeset -gU cdpath fpath mailpath path

# Set the the list of directories that cd searches.
# cdpath=(
#   $cdpath
# )


#================
# plugin manager
#================

export ZPLUG_HOME=/usr/local/opt/zplug
source $ZPLUG_HOME/init.zsh
# export ZPLUG_CLONE_DEPTH=1
zstyle :zplug:tag depth 1

zplug "b4b4r07/zplug"
zplug "zsh-users/zsh-syntax-highlighting", defer:2 
zplug "zsh-users/zsh-history-substring-search"
zplug "zsh-users/zsh-autosuggestions"
zplug "zsh-users/zsh-completions"
zplug "tcnksm/docker-alias", use:zshrc, as:plugin
zplug "k4rthik/git-cal", as:command
zplug "junegunn/fzf-bin", as:command, from:gh-r, rename-to:fzf
zplug "junegunn/fzf", as:command, use:bin/fzf-tmux
zplug "mollifier/anyframe"
zplug "b4b4r07/enhancd", use:enhancd.sh

# check コマンドで未インストール項目があるかどうか verbose にチェックし
# false のとき（つまり未インストール項目がある）y/N プロンプトで
# インストールする
if ! zplug check --verbose; then
    printf "Install .zshrc? [y/N]: "
    if read -q; then
        echo; zplug install
    fi
fi

# プラグインを読み込み、コマンドにパスを通す
zplug load --verbose

## cdr for anyframe
autoload -Uz chpwd_recent_dirs cdr add-zsh-hook
add-zsh-hook chpwd chpwd_recent_dirs

bindkey '^xb' anyframe-widget-cdr
bindkey '^x^b' anyframe-widget-checkout-git-branch

bindkey '^xr' anyframe-widget-execute-history
bindkey '^x^r' anyframe-widget-execute-history

bindkey '^xi' anyframe-widget-put-history
bindkey '^x^i' anyframe-widget-put-history

bindkey '^xg' anyframe-widget-cd-ghq-repository
bindkey '^x^g' anyframe-widget-cd-ghq-repository

bindkey '^xk' anyframe-widget-kill
bindkey '^x^k' anyframe-widget-kill

bindkey '^xe' anyframe-widget-insert-git-branch
bindkey '^x^e' anyframe-widget-insert-git-branch


#=============================
# utlity
#==============================
function exists() { type -a $1 &> /dev/null; }

#=============
# environment
#=============

bindkey -e
export PAGER='less'
export LESS='-N -R -X -i --no-init --LONG-PROMPT --ignore-case'
export LESSOPEN='| src-hilite-lesspipe.sh %s'
export MORE='-R'
export LV='-la -Ou8 -c'
export JAVA_HOME=$(/usr/libexec/java_home)
export LANG=ja_JP.UTF-8
export RBENV_ROOT=/usr/local/opt/rbenv
export EDITOR='emacsclient'
export VISUAL='emacsclient'
export HOMEBREW_CASK_OPTS="--appdir=/Applications"
export HISTFILE=${HOME}/.zsh_history # 履歴ファイルの保存先
export HISTSIZE=10000 # メモリに保存される履歴の件数
export SAVEHIST=100000 # 履歴ファイルに保存される履歴の件数

export XDG_CONFIG_HOME=$HOME/.config

if exists go; then
    export GOROOT=$(go env GOROOT)
    export GOPATH=$HOME/.go:$HOME/godev
fi

export NVM_DIR=~/.nvm

## path
path=(
    $JAVA_HOME/bin(N-/)
    /usr/local/bin(N-/)
    /usr/local/sbin(N-/)
    $HOME/bin(N-/)
    $HOME/.cabal/bin(N-/)
    $GOPATH/bin(N-/)
    $path
)
export path

# fpath
fpath=(
    /usr/local/share/zsh-completions(N-/) \
    /usr/local/share/zsh/site-functions(N-/) \
    $fpath
)


## completion
autoload -U compinit
compinit -u

### 補完方法毎にグループ化する。
zstyle ':completion:*' format '%B%F{blue}%d%f%b'
zstyle ':completion:*' group-name ''
### 補完侯補をメニューから選択する。
### select=2: 補完候補を一覧から選択する。補完候補が2つ以上なければすぐに補完する。
# zstyle ':completion:*:default' menu select=2
zstyle ':completion:*:default' menu select=1

### 補完候補に色を付ける。
zstyle ':completion:*' list-colors "${(s.:.)LS_COLORS}"
### 補完候補がなければより曖昧に候補を探す。
### m:{a-z}={A-Z}: 小文字を大文字に変えたものでも補完する。
### r:|[._-]=*: 「.」「_」「-」の前にワイルドカード「*」があるものとして補完する。
zstyle ':completion:*' matcher-list 'm:{a-z}={A-Z} r:|[._-]=*'
zstyle ':completion:*' keep-prefix
zstyle ':completion:*' recent-dirs-insert both

### 補完候補
### _oldlist 前回の補完結果を再利用する。
### _complete: 補完する。
### _match: globを展開しないで候補の一覧から補完する。
### _history: ヒストリのコマンドも補完候補とする。
### _ignored: 補完候補にださないと指定したものも補完候補とする。
### _approximate: 似ている補完候補も補完候補とする。
### _prefix: カーソル以降を無視してカーソル位置までで補完する。
#zstyle ':completion:*' completer _oldlist _complete _match _history _ignored _approximate _prefix
zstyle ':completion:*' completer _complete _ignored

## 補完候補をキャッシュする。
zstyle ':completion:*' use-cache yes
zstyle ':completion:*' cache-path ~/.zsh/cache


## options: utility
setopt always_last_prompt  # 無駄なスクロールを避ける
setopt append_history  # 複数の zsh を同時に使う時など history ファイルに上書きせず追加
setopt auto_cd # ディレクトリ名だけでcd
setopt auto_list  # 補完候補が複数ある時に、一覧表示
setopt auto_menu  # 補完候補が複数あるときに自動的に一覧表示する
setopt auto_pushd # cd - で候補選択
setopt autoremoveslash
setopt complete_aliases # completion の時も
setopt complete_in_word  # カーソル位置で補完する。
setopt equals # =command を command のパス名に展開する
setopt extended_glob  # 拡張globを有効にする。
setopt extended_history  # 履歴ファイルに時刻を記録
setopt glob
setopt glob_complete  # globを展開しないで候補の一覧から補完する。
setopt hist_expand # 補完時にヒストリを自動的に展開
setopt hist_ignore_all_dups # ヒストリに重複を残さない、同じコマンドの場合古いのは消す
setopt hist_ignore_dups   # 直前と同じコマンドラインはヒストリに追加しない
setopt hist_no_store # history コマンドをヒストリリストから取り除く
setopt hist_reduce_blanks # 余分なスペースを削除してひすとりに追加
setopt hist_verify # ヒストリを呼び出してから実行する間に編集可能に
setopt ignoreeof       # ^Dでログアウトしない
setopt inc_append_history # 履歴をインクリメンタルに追加
setopt list_packed # 補完結果をなるべくつめる
setopt list_types # 補完候補一覧でファイルの種別を識別マーク表示
setopt magic_equal_subst  # コマンドライン引数の --prefix=/usr とか=以降でも補完
setopt mark_dirs   # globでパスを生成したときに、パスがディレクトリだったら最後に「/」をつける。
setopt no_beep  # 補完候補がないときなどにビープ音を鳴らさない。
setopt no_flow_control # Ctrl+S, Ctrl+Qによる制御を無効に
setopt no_nomatch # git show HEAD^とかrake foo[bar]とか使いたい
setopt numeric_glob_sort  # 辞書順ではなく数字順に並べる。
setopt print_eight_bit # 日本語ファイル名を表示可能に
setopt prompt_subst  # PROMPT内で変数展開・コマンド置換・算術演算を実行
setopt pushd_ignore_dups # 同じディレクトリをpushしない
setopt share_history  # シェルのプロセスごとに履歴を共有
setopt transient_rprompt  # コマンド実行後は右プロンプトを消す
unsetopt list_beep


###############################
# Alias configuration
#  expand aliases before completing
###############################
alias ls='ls -GF'
alias lsal='ls -al'
alias ll='ls -al'

###############################
# path priority
###############################
alias mvn='/usr/local/bin/mvn'

###############################
# cover mistype
###############################
alias ,,='cd ../'
alias //_='cd ../'
alias ...='cd ../'

# aliases for all shells
alias cp='cp -i'
alias df='df -h'
alias dir='ls -l'
alias du='du -h'
alias grep='grep --color'
alias j="jobs -l"
alias jobs='jobs -l'
alias mv='mv -i'
alias rm='rm -i'
alias whence='type -a'
alias where="command -v"
alias diff='colordiff'

# alias for git
alias g='git'
alias t='tig'
alias ta='tig --all'

# global aliases
alias -g L='|less'
alias -g H='|head'
alias -g T='|tail'
alias -g G='|grep'
alias -g V='|vim -R -'
alias -g X='|xargs'
alias -g B='`git branch -a | peco --prompt "GIT BRANCH>" | head -n 1 | sed -e "s/^\*\s*//g"`'
alias -g R='`git remote | peco --prompt "GIT REMOTE>" | head -n 1`'
alias -g H='`curl -sL https://api.github.com/users/makotow/repos | jq -r ".[].full_name" | peco --prompt "GITHUB REPOS>" | head -n 1`'
alias -g LR='`git branch -a | peco --query "remotes/ " --prompt "GIT REMOTE BRANCH>" | head -n 1 | sed "s/remotes\/[^\/]*\/\(\S*\)/\1 \0/"`'

# 3秒以上かかった処理は詳細表示
REPORTTIME=3

#=============================
# source z.sh
#=============================
if exists brew; then  . `brew --prefix`/etc/profile.d/z.sh; fi

#=============================
# direnv
#=============================
if exists direnv; then eval "$(direnv hook zsh)"; fi

#=============================#
# command-line stack
#=============================#
show_buffer_stack() {
    POSTDISPLAY="
stack: $LBUFFER"
    zle push-line-or-edit
}
zle -N show_buffer_stack


#=============================#
# version manager
#=============================#

# ruby version manager
if exists rbenv; then
    eval "$(rbenv init - zsh)";
    . $RBENV_ROOT/completions/rbenv.zsh
fi

# node version manager
source $(brew --prefix nvm)/nvm.sh

# python version manager
if exists pyenv; then eval "$(pyenv init -)"; fi

# perl version manager
 if exists plenv; then eval "$(plenv init - zsh)"; fi

#===========================#
# peco
#===========================#
function peco-select-history() {
    local tac
    if exists tac;  then
        tac="tac"
    else
        tac="tail -r"
    fi
    BUFFER=$(history -n 1 | \
                 eval $tac | \
                 peco --query "$LBUFFER")
    CURSOR=$#BUFFER
    # zle clear-screen
}
zle -N peco-select-history
bindkey '^r' peco-select-history

function peco-src () {
    local selected_dir=$(ghq list --full-path | peco --query "$LBUFFER")
    if [ -n "$selected_dir" ]; then
        BUFFER="cd ${selected_dir}"
        zle accept-line
    fi
    zle clear-screen
}
zle -N peco-src
bindkey '^S' peco-src

function peco-godoc() {
    local selected_dir=$(ghq list --full-path | peco --query "$LBUFFER")
    if [ -n "$selected_dir" ]; then
        BUFFER="godoc ${selected_dir} | less"
        zle accept-line
    fi
    zle clear-screen
}

#=========================
# Mac ONLY:
# Spotlight cli and filter using peco.
#=========================
function fcd() {

    if [ -z "$1" ]; then
        return 1
    fi

    local MD_QUERY="kMDItemContentType == 'public.folder' && kMDItemFSName == '$1*'"

    local RESULT=$(mdfind -onlyin ~ "$MD_QUERY" | peco)

    if [ -z "$RESULT" ]; then
        return 1
    fi

    echo $RESULT
    cd $RESULT
}


zle -N peco-godoc
typeset -U path PATH

#==========================
# Prompt
#==========================
autoload -U promptinit
autoload -U colors && colors

PROMPT="
%{$fg[cyan]%}[%D{%Y-%m-%d %H:%M:%S}]:[%n@%m]:[%~] %{${reset_color}%}
"

# Googleカラーでサジェスト #
setopt correct
SPROMPT=" ＜ %{$fg[blue]%}も%{${reset_color}%}%{$fg[red]%}し%{${reset_color}%}%{$fg[yellow]%}か%{${reset_color}%}%{$fg[green]%}し%{${reset_color}%}%{$fg[red]%}て%{${reset_color}%}: %{$fg[red]%}%r%{${reset_color}%}？ [(y)es,(n)o,(a)bort,(e)dit]
-> "

autoload -Uz vcs_info
setopt prompt_subst
zstyle ':vcs_info:git:*' check-for-changes true
zstyle ':vcs_info:git:*' stagedstr "%F{yellow}!"
zstyle ':vcs_info:git:*' unstagedstr "%F{red}+"
zstyle ':vcs_info:*' formats "%F{green}%c%u[%b]%f"
zstyle ':vcs_info:*' actionforpymats '[%b|%a]'
precmd () { vcs_info }
RPROMPT=$RPROMPT'${vcs_info_msg_0_}'


# Execute code that does not affect the current session in the background.
{
    # Compile the completion dump to increase startup speed.
    zcompdump="${ZDOTDIR:-$HOME}/.zcompdump"
    if [[ -s "$zcompdump" && (! -s "${zcompdump}.zwc" || "$zcompdump" -nt "${zcompdump}.zwc") ]]; then
        zcompile "$zcompdump"
    fi
} &!

# pip zsh completion start
function _pip_completion {
    local words cword
    read -Ac words
    read -cn cword
    reply=( $( COMP_WORDS="$words[*]" \
                         COMP_CWORD=$(( cword-1 )) \
                         PIP_AUTO_COMPLETE=1 $words[1] ) )
}
compctl -K _pip_completion pip



#===========================#
# tmux session
#===========================#
#[[ -z "$TMUX" && ! -z "$PS1" ]] && tmux

# Performance
if type zprof > /dev/null 2>&1; then
	  zprof | less
fi
